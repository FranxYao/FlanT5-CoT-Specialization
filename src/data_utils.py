"""Data utils for the gsm8k dataset"""

import time
from .utils import tprint

def parse_step_prob(p):
    assert("'<<'" not in p)
    p = p.split('<<')
    p_ = []
    for pi in p:
        if('>>' not in pi): continue
        if("'>>'" not in pi):
            pi = pi.split('>>')
            assert(len(pi) == 2)
        else: 
            pi = [pi[:-10], pi[-8:]]
            # print(pi)
        tok = pi[0][1:-1].replace('\\n', '\n')
        prob = float(pi[1].strip())
        p_.append((tok, prob))
    return p_

def parse_codex_outputs(lines):
    questions = []
    answers = []
    ans_pred = []
    per_step_prob = []
    mode = ""
    ans_list = None
    for li, l in enumerate(lines):
        if(l.startswith('Question')):
            if(mode == 'm' or mode == 'none'):
                mode = 'none'
                continue
            q = l
            mode = 'q'
            if(ans_list is not None):
                ans_pred.append(ans_list)
                per_step_prob.append(prob_list)
            ans_list = []
            prob_list = []
        elif(l.startswith('Answer: ')):
            questions.append(q)
            a = [l]
            mode = 'a'
        elif(l.startswith('Model output')):
            if(l.startswith('Model output 0')):
                answers.append(''.join(a))
            mode = 'm'
            m = [l]
        elif(l.startswith('Per-step')):
            ans_list.append(''.join(m))
            mode = 'p'
            prob_list.append(l)
        else:
            if(mode == 'a'):
                a.append(l)
            elif(mode == 'm'):
                m.append(l)
            elif(mode == 'p'): 
                pass
            elif(mode == 'none'):
                pass
            else:
                print(mode)
                print(li)
                print(lines[li - 1])
                print(l)
                raise ValueError() 
    ans_pred.append(ans_list)
    per_step_prob.append(prob_list)
    
    per_step_prob_ = []
    for p in per_step_prob:
        p_ = []
        for i, pi in enumerate(p):
            if(i == 0): pi = pi.split('Per-step decode: ')[1] 
            pi = pi.split(' ||| ')
            pi_ = []
            for pij in pi: pi_.append(parse_step_prob(pij))
            p_.append(pi_)
        # p_ = parse_step_prob(p_)
        per_step_prob_.append(p_)
    
    return questions, answers, ans_pred, per_step_prob_

def load_codex_generated(data_path):
    """load the codex generated gsm8k data
    
    Args:
        data_path (str): path to the codex generated gsm8k data

    Returns:

    """
    tprint('Loading codex generated gsm8k data ... ')
    start_time = time.time()
    data_path += 'train_codex_complex_duplicate.txt'

    # load positive data
    positive_lines = open(data_path).readlines()
    questions, answers, ans_pred, per_step_prob = parse_codex_outputs(positive_lines)
    tprint('Done loading codex generated gsm8k data in {:.2f} seconds'\
        .format(time.time() - start_time))

    # TODO: remove starting tokens generated by codex 

    # load negative data
    return 

def match_gpt3_token_to_t5_token(gpt3_token_probs):
    """Match the gpt3 token to t5 token

    Args:
    """
    return 